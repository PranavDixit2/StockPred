# -*- coding: utf-8 -*-
"""StockPred_v5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19H7lA1GrLA7gaFhnki6F9z9HmblXtBgI
"""

import os
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, Bidirectional
from tensorflow.keras.regularizers import l2
import tensorflow as tf

# Function to fetch stock data with input validation
def fetch_stock_data(ticker):
    try:
        stock_data = yf.download(ticker)
        if stock_data.empty:
            raise ValueError("No data found. Please check the ticker symbol.")
        print("Stock data fetched:")
        print(stock_data.tail(5))
        return stock_data
    except Exception as e:
        print(f"Error fetching stock data: {e}")
        exit()

# Function to calculate EMA
def calculate_ema(data, span):
    return data['Close'].ewm(span=span, adjust=False).mean()

# Function to calculate RSI
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Function to calculate Bollinger Bands
def calculate_bollinger_bands(data, window=20):
    sma = data['Close'].rolling(window=window).mean()
    std_dev = data['Close'].rolling(window=window).std()
    data['Bollinger_Upper'] = sma + (2 * std_dev)
    data['Bollinger_Lower'] = sma - (2 * std_dev)
    return data

# Function to calculate MACD
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    short_ema = data['Close'].ewm(span=short_window, adjust=False).mean()
    long_ema = data['Close'].ewm(span=long_window, adjust=False).mean()
    data['MACD'] = short_ema - long_ema
    data['MACD_Signal'] = data['MACD'].ewm(span=signal_window, adjust=False).mean()
    return data

# Function to calculate additional features
def calculate_features(data):
    data['EMA_9'] = calculate_ema(data, 9)
    data['EMA_21'] = calculate_ema(data, 21)
    data['EMA_50'] = calculate_ema(data, 50)
    data['EMA_200'] = calculate_ema(data, 200)
    data['RSI'] = calculate_rsi(data)
    data = calculate_bollinger_bands(data)
    data = calculate_macd(data)

    # Volume change percentage
    data['Volume_Change'] = data['Volume'].pct_change()

    # Lagged values of the target variable and other features
    for lag in range(1, 6):  # Adding lagged values for the last 5 days
        data[f'Lag_Close_{lag}'] = data['Close'].shift(lag)
        data[f'Lag_Volume_{lag}'] = data['Volume'].shift(lag)
        data[f'Lag_EMA_9_{lag}'] = data['EMA_9'].shift(lag)
        data[f'Lag_RSI_{lag}'] = data['RSI'].shift(lag)
        data[f'Lag_MACD_{lag}'] = data['MACD'].shift(lag)
        data[f'Lag_Bollinger_Upper_{lag}'] = data['Bollinger_Upper'].shift(lag)
        data[f'Lag_Bollinger_Lower_{lag}'] = data['Bollinger_Lower'].shift(lag)

    data['Price_Change'] = data['Close'].pct_change()  # Price change percentage

    # Drop rows with NaN values
    data.dropna(inplace=True)
    print("Features calculated:")
    print(data.head())
    return data

# Function to preprocess data
def preprocess_data(data):
    data['Target'] = data['Close'].shift(-1)  # Predict the next day's closing price
    data.dropna(inplace=True)
    features = ['Open', 'High', 'Low', 'Close', 'Volume', 'EMA_9', 'EMA_21', 'EMA_50', 'EMA_200',
                'RSI', 'Bollinger_Upper', 'Bollinger_Lower', 'MACD', 'MACD_Signal', 'Volume_Change'] + \
                [f'Lag_Close_{lag}' for lag in range(1, 6)] + \
                [f'Lag_Volume_{lag}' for lag in range(1, 6)] + \
                [f'Lag_EMA_9_{lag}' for lag in range(1, 6)] + \
                [f'Lag_RSI_{lag}' for lag in range(1, 6)] + \
                [f'Lag_MACD_{lag}' for lag in range(1, 6)] + \
                [f'Lag_Bollinger_Upper_{lag}' for lag in range(1, 6)] + \
                [f'Lag_Bollinger_Lower_{lag}' for lag in range(1, 6)] + \
                ['Price_Change']
    print("Data after preprocessing:")
    print(data.head())
    return data, features

# Function to build and train LSTM model
def train_lstm_model(X_train, y_train, X_test, y_test, learning_rate=0.001, batch_size=64, epochs=100,model_save_path='lstm_model.h5'):
    model = Sequential([
        Bidirectional(LSTM(128, return_sequences=True, kernel_regularizer=l2(0.01), input_shape=(X_train.shape[1], X_train.shape[2]))),
        Dropout(0.5),
        Bidirectional(LSTM(64, kernel_regularizer=l2(0.01))),
        Dropout(0.5),
        Dense(1)  # Change to a single neuron for regression
    ])

    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=learning_rate),
                  loss='mean_squared_error', metrics=['mae'])  # Use MSE for regression
    print("Training LSTM model...")
    history = model.fit(
        X_train, y_train,
        epochs=epochs,
        batch_size=batch_size,
        validation_data=(X_test, y_test),
        callbacks=[
            tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True),
            tf.keras.callbacks.ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=5, min_lr=1e-6)
        ]
    )
    print("Training completed. Model performance:")
    print(f"Train MAE: {history.history['mae'][-1]:.2f}")
    print(f"Validation MAE: {history.history['val_mae'][-1]:.2f}")

    # Save the model
    model.save(model_save_path)
    print(f"Model saved to {model_save_path}")

    return model

# Function to prepare data for LSTM
def prepare_data(data, features, window_size=10):
    feature_scaler = MinMaxScaler()
    target_scaler = MinMaxScaler()

    scaled_features = feature_scaler.fit_transform(data[features])
    print("Scaled features:")
    print(scaled_features[:5])

    X = np.array([scaled_features[i-window_size:i] for i in range(window_size, len(scaled_features))])
    y = data['Target'].values[window_size:]

    # Normalize the target variable
    y = target_scaler.fit_transform(y.reshape(-1, 1)).flatten()

    print("Prepared data for LSTM:")
    print(f"X shape: {X.shape}, y shape: {y.shape}")
    return X, y, feature_scaler, target_scaler

# Function to predict the next day's stock price
def predict_next_day(model, data, features, feature_scaler, target_scaler, window_size=10):
    last_data = data[features].values[-window_size:]
    last_data_scaled = feature_scaler.transform(last_data)
    last_data_reshaped = last_data_scaled.reshape((1, window_size, len(features)))

    predicted_price = model.predict(last_data_reshaped)[0][0]  # Directly get the predicted price
    predicted_price = target_scaler.inverse_transform([[predicted_price]])[0][0]  # Inverse transform to get actual price
    return predicted_price

import os
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, Bidirectional
from tensorflow.keras.regularizers import l2
import tensorflow as tf
import streamlit as st

st.set_page_config(page_title="Stock Price LSTM Predictor", layout="wide")

@st.cache_data
def fetch_stock_data(ticker):
    try:
        data = yf.download(ticker)
        if data.empty:
            raise ValueError("No data found. Check ticker symbol.")
        return data
    except Exception as e:
        st.error(f"Error fetching stock data: {e}")
        return None

# --- Feature functions ---
def calculate_ema(data, span): return data['Close'].ewm(span=span, adjust=False).mean()
def calculate_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window).mean()
    rs = gain / (loss + 1e-8)
    return 100 - (100 / (1 + rs))

def calculate_bollinger_bands(data, window=20):
    sma = data['Close'].rolling(window).mean()
    std = data['Close'].rolling(window).std()
    data['Bollinger_Upper'] = sma + 2*std
    data['Bollinger_Lower'] = sma - 2*std
    return data

def calculate_macd(data):
    short_ema = data['Close'].ewm(span=12, adjust=False).mean()
    long_ema = data['Close'].ewm(span=26, adjust=False).mean()
    data['MACD'] = short_ema - long_ema
    data['MACD_Signal'] = data['MACD'].ewm(span=9, adjust=False).mean()
    return data

def calculate_features(data):
    data['EMA_9'] = calculate_ema(data, 9)
    data['EMA_21'] = calculate_ema(data, 21)
    data['EMA_50'] = calculate_ema(data, 50)
    data['EMA_200'] = calculate_ema(data, 200)
    data['RSI'] = calculate_rsi(data)
    data = calculate_bollinger_bands(data)
    data = calculate_macd(data)
    data['Volume_Change'] = data['Volume'].pct_change()
    for lag in range(1,6):
        data[f'Lag_Close_{lag}'] = data['Close'].shift(lag)
        data[f'Lag_Volume_{lag}'] = data['Volume'].shift(lag)
        data[f'Lag_EMA_9_{lag}'] = data['EMA_9'].shift(lag)
        data[f'Lag_RSI_{lag}'] = data['RSI'].shift(lag)
        data[f'Lag_MACD_{lag}'] = data['MACD'].shift(lag)
        data[f'Lag_Bollinger_Upper_{lag}'] = data['Bollinger_Upper'].shift(lag)
        data[f'Lag_Bollinger_Lower_{lag}'] = data['Bollinger_Lower'].shift(lag)
    data['Price_Change'] = data['Close'].pct_change()
    data.dropna(inplace=True)
    return data

def preprocess_data(data):
    data['Target'] = data['Close'].shift(-1)
    data.dropna(inplace=True)
    features = ['Open','High','Low','Close','Volume','EMA_9','EMA_21','EMA_50','EMA_200',
                'RSI','Bollinger_Upper','Bollinger_Lower','MACD','MACD_Signal','Volume_Change'] + \
               [f'Lag_Close_{lag}' for lag in range(1,6)] + \
               [f'Lag_Volume_{lag}' for lag in range(1,6)] + \
               [f'Lag_EMA_9_{lag}' for lag in range(1,6)] + \
               [f'Lag_RSI_{lag}' for lag in range(1,6)] + \
               [f'Lag_MACD_{lag}' for lag in range(1,6)] + \
               [f'Lag_Bollinger_Upper_{lag}' for lag in range(1,6)] + \
               [f'Lag_Bollinger_Lower_{lag}' for lag in range(1,6)] + ['Price_Change']
    return data, features

def prepare_data(data, features, window_size):
    feature_scaler = MinMaxScaler()
    target_scaler = MinMaxScaler()
    scaled_features = feature_scaler.fit_transform(data[features])
    X = np.array([scaled_features[i-window_size:i] for i in range(window_size,len(scaled_features))])
    y = target_scaler.fit_transform(data['Target'].values[window_size:].reshape(-1,1)).flatten()
    return X, y, feature_scaler, target_scaler

def train_lstm_model(X_train, y_train, X_test, y_test, epochs=50, batch_size=32, lr=0.001):
    model = Sequential([
        Bidirectional(LSTM(128, return_sequences=True, kernel_regularizer=l2(0.01), input_shape=(X_train.shape[1], X_train.shape[2]))),
        Dropout(0.5),
        Bidirectional(LSTM(64, kernel_regularizer=l2(0.01))),
        Dropout(0.5),
        Dense(1)
    ])
    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=lr), loss='mse', metrics=['mae'])
    history = model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=epochs, batch_size=batch_size,
                        callbacks=[tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)],
                        verbose=0)
    return model

def predict_next_day(model, data, features, feature_scaler, target_scaler, window_size):
    last_window = data[features].values[-window_size:]
    last_window_scaled = feature_scaler.transform(last_window).reshape(1,window_size,len(features))
    pred_scaled = model.predict(last_window_scaled)[0][0]
    return target_scaler.inverse_transform([[pred_scaled]])[0][0]

# --- Streamlit UI ---
st.title("ðŸ“ˆ Stock Price LSTM Predictor")

ticker = st.text_input("Enter Stock Ticker:", "AAPL")
window_size = st.slider("LSTM Window Size", 5, 30, 10)
test_size_ratio = st.slider("Test Size (%)", 10, 50, 20)
epochs = st.slider("Epochs", 10, 200, 50)
batch_size = st.slider("Batch Size", 16, 128, 32)

if st.button("Run Prediction"):
    data = fetch_stock_data(ticker)
    if data is not None:
        data = data.tail(90)
        data = calculate_features(data)
        data, features = preprocess_data(data)
        X, y, feature_scaler, target_scaler = prepare_data(data, features, window_size)
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size_ratio/100, random_state=42)
        with st.spinner("Training LSTM model..."):
            model = train_lstm_model(X_train, y_train, X_test, y_test, epochs=epochs, batch_size=batch_size)
        st.success("Model trained!")

        # Predictions
        y_pred = model.predict(X_test).flatten()
        y_pred_actual = target_scaler.inverse_transform(y_pred.reshape(-1,1)).flatten()
        y_test_actual = target_scaler.inverse_transform(y_test.reshape(-1,1)).flatten()

        # Metrics
        mae = mean_absolute_error(y_test_actual, y_pred_actual)
        mse = mean_squared_error(y_test_actual, y_pred_actual)
        rmse = np.sqrt(mse)
        mape = np.mean(np.abs((y_test_actual - y_pred_actual)/(y_test_actual+1e-8)))*100
        st.subheader("Evaluation Metrics")
        st.write(f"MAE: {mae:.2f}, MSE: {mse:.2f}, RMSE: {rmse:.2f}, MAPE: {mape:.2f}%")

        # Next day prediction
        next_price = predict_next_day(model, data, features, feature_scaler, target_scaler, window_size)
        st.write(f"Predicted next day closing price: ${next_price:.2f}")

        # Plot
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=data.index[-len(y_test_actual):], y=y_test_actual, name="Actual", line=dict(color="blue")))
        fig.add_trace(go.Scatter(x=data.index[-len(y_test_actual):], y=y_pred_actual, name="Predicted", line=dict(color="red")))
        st.plotly_chart(fig)







